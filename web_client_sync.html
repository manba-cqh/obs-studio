<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³è§†é¢‘åŒæ­¥WebSocketå®¢æˆ·ç«¯</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        input[type="text"], input[type="number"] {
            padding: 10px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: #667eea;
            outline: none;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(81, 207, 102, 0.3);
        }
        
        .status {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            margin: 10px 0;
        }
        
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .video-container {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        #videoCanvas {
            width: 100%;
            height: auto;
            display: block;
            background: #000;
        }
        
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .sync-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            color: #1565c0;
            padding: 15px;
            border-radius: 10px;
            margin: 20px;
            text-align: center;
        }
        
        .sync-info h3 {
            margin: 0 0 10px 0;
            color: #0d47a1;
        }
        
        .sync-status {
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .sync-good { color: #2e7d32; }
        .sync-warning { color: #f57c00; }
        .sync-bad { color: #c62828; }
        
        .audio-controls {
            background: #f1f3f4;
            padding: 15px;
            border-radius: 10px;
            margin: 20px;
            text-align: center;
        }
        
        .audio-controls h3 {
            margin: 0 0 15px 0;
            color: #5f6368;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 10px 0;
        }
        
        .volume-slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¥ éŸ³è§†é¢‘åŒæ­¥WebSocketå®¢æˆ·ç«¯</h1>
            <p>å®æ—¶æ¥æ”¶å’ŒåŒæ­¥éŸ³è§†é¢‘æµï¼Œæ”¯æŒä½å»¶è¿Ÿæ’­æ”¾</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>æœåŠ¡å™¨åœ°å€:</label>
                <input type="text" id="serverUrl" value="ws://localhost:8765" style="width: 200px;">
                <button class="btn-primary" onclick="connect()">è¿æ¥</button>
                <button class="btn-danger" onclick="disconnect()">æ–­å¼€</button>
            </div>
            
            <div class="control-group">
                <label>éŸ³é¢‘æ•è·:</label>
                <button class="btn-success" onclick="startAudioCapture()">å¯åŠ¨éŸ³é¢‘</button>
                <button class="btn-danger" onclick="stopAudioCapture()">åœæ­¢éŸ³é¢‘</button>
                <span id="audioStatus" style="margin-left: 10px; color: #666;">æœªå¯åŠ¨</span>
            </div>
            
                    <div id="connectionStatus" class="status disconnected">æœªè¿æ¥</div>
    </div>
    
    <!-- åº”ç”¨ç¨‹åºåˆ—è¡¨éƒ¨åˆ† -->
    <div class="applications-section" style="padding: 20px; background: #f8f9fa; border-bottom: 1px solid #e9ecef;">
        <h3>ğŸ’» è¿œç¨‹åº”ç”¨ç¨‹åºæ§åˆ¶</h3>
        <div class="control-group">
            <button class="btn-primary" onclick="refreshApplications()">ğŸ”„ åˆ·æ–°åº”ç”¨ç¨‹åºåˆ—è¡¨</button>
            <button class="btn-success" onclick="searchApplications()">ğŸ” æœç´¢åº”ç”¨ç¨‹åº</button>
            <input type="text" id="appSearchInput" placeholder="è¾“å…¥åº”ç”¨ç¨‹åºåç§°æœç´¢..." style="width: 250px;">
        </div>
        
        <div class="applications-container" style="margin-top: 15px;">
            <div class="applications-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <span style="font-weight: bold; color: #495057;">åº”ç”¨ç¨‹åºåˆ—è¡¨ (<span id="appCount">0</span>)</span>
                <span id="lastUpdateTime" style="font-size: 0.9em; color: #6c757d;">æœªæ›´æ–°</span>
            </div>
            
            <div class="applications-list" id="applicationsList" style="max-height: 400px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; background: white;">
                <div style="padding: 20px; text-align: center; color: #6c757d;">
                    ç­‰å¾…è¿æ¥æœåŠ¡å™¨è·å–åº”ç”¨ç¨‹åºåˆ—è¡¨...
                </div>
            </div>
            
            <div class="launch-status" id="launchStatus" style="margin-top: 10px; padding: 10px; border-radius: 5px; display: none;"></div>
        </div>
    </div>
    
    <div class="video-container">
            <canvas id="videoCanvas" width="1280" height="720"></canvas>
            <div class="overlay">
                <div>åˆ†è¾¨ç‡: <span id="resolution">1280x720</span></div>
                <div>å¸§ç‡: <span id="fps">0</span> FPS</div>
                <div>å»¶è¿Ÿ: <span id="latency">0</span> ms</div>
            </div>
        </div>
        
        <div class="sync-info">
            <h3>ğŸ”„ éŸ³è§†é¢‘åŒæ­¥çŠ¶æ€</h3>
            <div class="sync-status" id="syncStatus">ç­‰å¾…è¿æ¥...</div>
            <p>éŸ³è§†é¢‘åŒæ­¥è´¨é‡å°†æ ¹æ®ç½‘ç»œå»¶è¿Ÿå’Œå¸§ç‡è‡ªåŠ¨è°ƒæ•´</p>
        </div>
        
        <div class="audio-controls">
            <h3>ğŸ”Š éŸ³é¢‘æ§åˆ¶</h3>
            <div class="volume-control">
                <label>éŸ³é‡:</label>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                <span id="volumeValue">50%</span>
            </div>
            <div style="margin-top: 15px;">
                <button class="btn-success" onclick="playTestTone()" style="margin-right: 10px;">ğŸµ æµ‹è¯•éŸ³è°ƒ</button>
                <button class="btn-primary" onclick="playTestSweep()" style="margin-right: 10px;">ğŸ“ˆ æ‰«é¢‘éŸ³</button>
                <button class="btn-primary" onclick="playWhiteNoise()" style="margin-right: 10px;">ğŸŒŠ ç™½å™ªå£°</button>
                <button class="btn-danger" onclick="stopTestAudio()">â¹ï¸ åœæ­¢</button>
                <button class="btn-primary" onclick="diagnoseAudio()" style="margin-left: 10px;">ğŸ” éŸ³é¢‘è¯Šæ–­</button>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px; border-left: 4px solid #ffc107;">
                <div style="font-weight: bold; margin-bottom: 5px;">ğŸ›ï¸ éŸ³é¢‘è´¨é‡ä¼˜åŒ–:</div>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <label>
                        <input type="checkbox" id="enableResampling" checked> å¯ç”¨é‡é‡‡æ ·
                    </label>
                    <label>
                        <input type="checkbox" id="enableSmoothing" checked> å¯ç”¨å¹³æ»‘æ»¤æ³¢
                    </label>
                    <label>
                        <input type="checkbox" id="enableCompression" checked> å¯ç”¨åŠ¨æ€å‹ç¼©
                    </label>
                    <label>
                        æ»¤æ³¢å¼ºåº¦: <input type="range" id="filterStrength" min="1" max="5" value="3" style="width: 80px;">
                        <span id="filterStrengthValue">3</span>
                    </label>
                </div>
                <div style="font-size: 0.85em; color: #856404; margin-top: 5px;">
                    ğŸ’¡ è¿™äº›è®¾ç½®å¯ä»¥å¸®åŠ©å‡å°‘éŸ³é¢‘åˆºå•¦å£°å’Œæ”¹å–„éŸ³è´¨
                </div>
            </div>
            
            <div style="margin-top: 15px;">
                <button class="btn-primary" id="recordButton" onclick="toggleRecording()" style="margin-right: 10px;">ğŸ™ï¸ å¼€å§‹å½•åˆ¶</button>
                <span id="recordingStatus" style="color: #666;">æœªå½•åˆ¶</span>
                <span id="recordingInfo" style="margin-left: 15px; font-size: 0.9em; color: #666;"></span>
                <button class="btn-primary" id="savePcmButton" onclick="saveCurrentAudioToPcm()" style="margin-left: 10px;">ğŸ’¾ ä¿å­˜PCM</button>
                <span id="pcmStatus" style="margin-left: 10px; color: #666;">æœªä¿å­˜</span>
                <button class="btn-primary" id="continuousPcmButton" onclick="toggleContinuousPcmSave()" style="margin-left: 10px;">ğŸ”„ è¿ç»­ä¿å­˜</button>
                <span id="continuousPcmStatus" style="margin-left: 10px; color: #666;">å·²å…³é—­</span>
            </div>
            <div style="margin-top: 15px;">
                <span id="audioInfo">éŸ³é¢‘: æœªæ¥æ”¶</span> | 
                <span id="videoInfo">è§†é¢‘: æœªæ¥æ”¶</span>
            </div>
            <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                ğŸ’¡ æµ‹è¯•éŸ³é¢‘åŠŸèƒ½å¯å¸®åŠ©éªŒè¯éŸ³é¢‘ç³»ç»Ÿæ˜¯å¦æ­£å¸¸å·¥ä½œ
            </div>
            <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                <div style="font-weight: bold; margin-bottom: 5px;">ğŸµ æµ‹è¯•éŸ³é¢‘è¯´æ˜:</div>
                <div style="font-size: 0.85em; line-height: 1.4;">
                    <strong>æµ‹è¯•éŸ³è°ƒ:</strong> 440Hz A4éŸ³è°ƒï¼ŒæŒç»­3ç§’ï¼Œç”¨äºæµ‹è¯•åŸºæœ¬éŸ³é¢‘æ’­æ”¾<br>
                    <strong>æ‰«é¢‘éŸ³:</strong> 20Hz-20kHzå¯¹æ•°æ‰«é¢‘ï¼ŒæŒç»­5ç§’ï¼Œç”¨äºæµ‹è¯•é¢‘ç‡å“åº”<br>
                    <strong>ç™½å™ªå£°:</strong> éšæœºå™ªå£°ï¼ŒæŒç»­2ç§’ï¼Œç”¨äºæµ‹è¯•éŸ³é¢‘ç³»ç»ŸåŠ¨æ€èŒƒå›´
                </div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalFrames">0</div>
                <div class="stat-label">æ€»å¸§æ•°</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="currentFps">0.0</div>
                <div class="stat-label">å½“å‰å¸§ç‡</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="dataSize">0 KB</div>
                <div class="stat-label">æ•°æ®å¤§å°</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgLatency">0 ms</div>
                <div class="stat-label">å¹³å‡å»¶è¿Ÿ</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="syncOffset">0 ms</div>
                <div class="stat-label">åŒæ­¥åç§»</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bufferHealth">100%</div>
                <div class="stat-label">ç¼“å†²åŒºå¥åº·åº¦</div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let websocket = null;
        let canvas = null;
        let ctx = null;
        let audioContext = null;
        let audioQueue = [];
        let videoQueue = [];
        let isConnected = false;
        let audioEnabled = false;
        
        // ç»Ÿè®¡å˜é‡
        let totalFrames = 0;
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let totalDataSize = 0;
        let latencySum = 0;
        let latencyCount = 0;
        let syncOffsets = [];
        
        // éŸ³è§†é¢‘åŒæ­¥ç›¸å…³
        let lastVideoTimestamp = 0;
        let lastAudioTimestamp = 0;
        let videoBuffer = [];
        let audioBuffer = [];
        let syncThreshold = 100; // åŒæ­¥é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰
        
        // éŸ³é¢‘å½•åˆ¶ç›¸å…³
        let isRecording = false;
        let recordedChunks = [];
        
        // PCMä¿å­˜ç›¸å…³
        let currentAudioData = null;
        let pcmSaveEnabled = false;
        let continuousPcmSave = false;
        let continuousPcmChunks = [];
        let continuousPcmStartTime = null;
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('videoCanvas');
            ctx = canvas.getContext('2d');
            
            // è®¾ç½®éŸ³é‡æ§åˆ¶
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            
            volumeSlider.addEventListener('input', function() {
                const volume = this.value / 100;
                volumeValue.textContent = this.value + '%';
                if (audioContext && audioContext.gain) {
                    audioContext.gain.gain.value = volume;
                }
            });
            
            // è®¾ç½®æ»¤æ³¢å¼ºåº¦æ§åˆ¶
            const filterStrengthSlider = document.getElementById('filterStrength');
            const filterStrengthValue = document.getElementById('filterStrengthValue');
            if (filterStrengthSlider && filterStrengthValue) {
                filterStrengthSlider.addEventListener('input', function() {
                    filterStrengthValue.textContent = this.value;
                    console.log(`æ»¤æ³¢å¼ºåº¦å·²è°ƒæ•´ä¸º: ${this.value}`);
                });
            }
            
            // å¯åŠ¨å¿ƒè·³æ£€æµ‹
            startHeartbeat();
            
            // å¯åŠ¨FPSè®¡æ•°å™¨
            startFpsCounter();
        });
        
        // è¿æ¥WebSocket
        function connect() {
            if (isConnected) return;
            
            const serverUrl = document.getElementById('serverUrl').value;
            updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');
            
            try {
                websocket = new WebSocket(serverUrl);
                
                websocket.onopen = function(event) {
                    isConnected = true;
                    updateConnectionStatus('connected', 'å·²è¿æ¥');
                    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                    
                    // è¯·æ±‚å¯åŠ¨éŸ³é¢‘æ•è·
                    websocket.send(JSON.stringify({
                        type: 'request_audio',
                        message: 'è¯·æ±‚å¯åŠ¨éŸ³é¢‘æ•è·'
                    }));
                };
                
                websocket.onmessage = function(event) {
                    handleMessage(event.data);
                };
                
                websocket.onclose = function(event) {
                    isConnected = false;
                    updateConnectionStatus('disconnected', 'è¿æ¥å·²æ–­å¼€');
                    console.log('WebSocketè¿æ¥å·²å…³é—­');
                    resetStats();
                };
                
                websocket.onerror = function(error) {
                    updateConnectionStatus('disconnected', 'è¿æ¥é”™è¯¯');
                    console.error('WebSocketé”™è¯¯:', error);
                };
                
            } catch (error) {
                updateConnectionStatus('disconnected', 'è¿æ¥å¤±è´¥: ' + error.message);
                console.error('è¿æ¥å¤±è´¥:', error);
            }
        }
        
        // æ–­å¼€è¿æ¥
        function disconnect() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            isConnected = false;
            updateConnectionStatus('disconnected', 'å·²æ–­å¼€');
        }
        
        // å¯åŠ¨éŸ³é¢‘æ•è·
        function startAudioCapture() {
            if (!isConnected) {
                alert('è¯·å…ˆè¿æ¥åˆ°æœåŠ¡å™¨');
                return;
            }
            
            websocket.send(JSON.stringify({
                type: 'start_audio',
                message: 'å¯åŠ¨éŸ³é¢‘æ•è·'
            }));
            
            document.getElementById('audioStatus').textContent = 'å·²è¯·æ±‚';
        }
        
        // åœæ­¢éŸ³é¢‘æ•è·
        function stopAudioCapture() {
            if (!isConnected) return;
            
            websocket.send(JSON.stringify({
                type: 'stop_audio',
                message: 'åœæ­¢éŸ³é¢‘æ•è·'
            }));
            
            document.getElementById('audioStatus').textContent = 'å·²è¯·æ±‚åœæ­¢';
        }
        
        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleMessage(data) {
            try {
                const message = JSON.parse(data);
                const messageType = message.type;
                
                switch (messageType) {
                    case 'connection':
                        console.log('è¿æ¥ç¡®è®¤:', message.message);
                        break;
                        
                    case 'frame':
                        handleVideoFrame(message);
                        break;
                        
                    case 'audio':
                        handleAudioData(message);
                        break;
                        
                    case 'audio_started':
                        audioEnabled = true;
                        document.getElementById('audioStatus').textContent = 'è¿è¡Œä¸­';
                        console.log('éŸ³é¢‘æ•è·å·²å¯åŠ¨');
                        break;
                        
                    case 'audio_stopped':
                        audioEnabled = false;
                        document.getElementById('audioStatus').textContent = 'å·²åœæ­¢';
                        console.log('éŸ³é¢‘æ•è·å·²åœæ­¢');
                        break;
                        
                    case 'applications_list':
                        handleApplicationsList(message);
                        break;
                        
                    case 'launch_result':
                        handleLaunchResult(message);
                        break;
                        
                    default:
                        console.log('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', messageType);
                }
                
            } catch (error) {
                console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
            }
        }
        
        // å¤„ç†è§†é¢‘å¸§
        function handleVideoFrame(frameData) {
            const startTime = Date.now();
            
            try {
                // åˆ›å»ºå›¾åƒå¯¹è±¡
                const img = new Image();
                img.onload = function() {
                    // ç»˜åˆ¶å›¾åƒåˆ°ç”»å¸ƒ
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    totalFrames++;
                    frameCount++;
                    totalDataSize += frameData.size || 0;
                    
                    // è®¡ç®—å»¶è¿Ÿ
                    const latency = Date.now() - startTime;
                    latencySum += latency;
                    latencyCount++;
                    
                    // æ›´æ–°åˆ†è¾¨ç‡æ˜¾ç¤º
                    document.getElementById('resolution').textContent = `${img.width}x${img.height}`;
                    
                    // å¤„ç†éŸ³è§†é¢‘åŒæ­¥
                    if (frameData.sync_timestamp && frameData.frame_index !== undefined) {
                        processVideoSync(frameData);
                    }
                };
                
                img.src = 'data:image/jpeg;base64,' + frameData.data;
                
            } catch (error) {
                console.error('å¤„ç†è§†é¢‘å¸§å¤±è´¥:', error);
            }
        }
        
        // å¤„ç†éŸ³é¢‘æ•°æ®
        function handleAudioData(audioData) {
            try {
                // console.log('=== å¼€å§‹å¤„ç†éŸ³é¢‘æ•°æ® ===');
                // console.log('åŸå§‹éŸ³é¢‘æ•°æ®:', audioData);
                
                // éªŒè¯éŸ³é¢‘æ•°æ®æ ¼å¼
                if (!audioData || !audioData.data || !audioData.format) {
                    console.error('éŸ³é¢‘æ•°æ®æ ¼å¼æ— æ•ˆ:', audioData);
                    return;
                }
                
                // æ£€æŸ¥éŸ³é¢‘æ ¼å¼æ˜¯å¦æ”¯æŒ
                if (audioData.format !== 'pcm') {
                    console.warn(`ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: ${audioData.format}`);
                    return;
                }
                
                // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                if (!audioContext) {
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œæ­£åœ¨åˆå§‹åŒ–...');
                    initAudioContext();
                }
                
                // è§£ç base64éŸ³é¢‘æ•°æ®
                // console.log('å¼€å§‹è§£ç base64éŸ³é¢‘æ•°æ®...');
                const audioBuffer = base64ToArrayBuffer(audioData.data);
                
                // éªŒè¯è§£ç åçš„æ•°æ®
                if (!audioBuffer || audioBuffer.byteLength === 0) {
                    console.error('éŸ³é¢‘æ•°æ®è§£ç å¤±è´¥');
                    return;
                }
                
                // console.log('éŸ³é¢‘æ•°æ®è§£ç æˆåŠŸ:', {
                //     byteLength: audioBuffer.byteLength,
                //     chunk: audioData.chunk,
                //     channels: audioData.channels,
                //     rate: audioData.rate
                // });
                
                // éªŒè¯æ•°æ®å¤§å°
                const expectedSize = audioData.chunk * audioData.channels * 2; // 16ä½ = 2å­—èŠ‚
                if (audioBuffer.byteLength !== expectedSize) {
                    console.warn(`éŸ³é¢‘æ•°æ®å¤§å°ä¸åŒ¹é…: æœŸæœ› ${expectedSize} å­—èŠ‚, å®é™… ${audioBuffer.byteLength} å­—èŠ‚`);
                }
                
                // å¤„ç†éŸ³è§†é¢‘åŒæ­¥
                if (audioData.sync_timestamp) {
                    processAudioSync(audioData);
                }
                
                // å¦‚æœæ­£åœ¨å½•åˆ¶ï¼Œæ·»åŠ åˆ°å½•åˆ¶ç¼“å†²åŒº
                if (isRecording) {
                    // è®¡ç®—å®é™…çš„æ ·æœ¬æ•°ï¼ˆåŸºäºæ•°æ®å¤§å°å’Œå£°é“æ•°ï¼‰
                    const actualChannels = audioData.channels || 2;
                    const bytesPerSample = 2; // 16ä½
                    const actualSamples = audioBuffer.byteLength / (actualChannels * bytesPerSample);
                    
                    recordedChunks.push({
                        data: audioBuffer,
                        timestamp: audioData.sync_timestamp || Date.now() / 1000,
                        channels: actualChannels,
                        rate: audioData.rate || 48000,
                        chunk: actualSamples
                    });
                    
                    // æ›´æ–°å½•åˆ¶ä¿¡æ¯æ˜¾ç¤º
                    const recordingInfo = document.getElementById('recordingInfo');
                    if (recordingInfo) {
                        recordingInfo.textContent = `${audioData.rate || 48000}Hz, ${actualChannels}å£°é“, ${recordedChunks.length}å—`;
                    }
                    
                    console.log(`éŸ³é¢‘æ•°æ®å·²æ·»åŠ åˆ°å½•åˆ¶ç¼“å†²åŒº: ${audioBuffer.byteLength} å­—èŠ‚, ${actualSamples} æ ·æœ¬, ${actualChannels} å£°é“, ${audioData.rate || 48000}Hz`);
                }
                
                // å¦‚æœæ­£åœ¨è¿ç»­ä¿å­˜PCMï¼Œæ·»åŠ åˆ°è¿ç»­ä¿å­˜ç¼“å†²åŒº
                if (continuousPcmSave) {
                    continuousPcmChunks.push({
                        data: audioBuffer,
                        timestamp: audioData.sync_timestamp || Date.now() / 1000,
                        channels: audioData.channels || 2,
                        rate: audioData.rate || 48000,
                        chunk: audioData.chunk || 0,
                        size: audioBuffer.byteLength
                    });
                    
                    // æ›´æ–°è¿ç»­ä¿å­˜çŠ¶æ€æ˜¾ç¤º
                    const continuousPcmInfo = document.getElementById('continuousPcmStatus');
                    if (continuousPcmInfo) {
                        const totalBytes = continuousPcmChunks.reduce((sum, chunk) => sum + chunk.size, 0);
                        const totalMB = (totalBytes / (1024 * 1024)).toFixed(2);
                        continuousPcmInfo.textContent = `å·²ä¿å­˜ ${continuousPcmChunks.length} å— (${totalMB} MB)`;
                        continuousPcmInfo.style.color = '#28a745';
                    }
                    
                    console.log(`éŸ³é¢‘æ•°æ®å·²æ·»åŠ åˆ°è¿ç»­PCMä¿å­˜ç¼“å†²åŒº: ${audioBuffer.byteLength} å­—èŠ‚, ${audioData.channels}å£°é“, ${audioData.rate}Hz`);
                }
                
                // æ’­æ”¾éŸ³é¢‘
                // console.log('å¼€å§‹æ’­æ”¾éŸ³é¢‘...');
                playAudio(audioBuffer);
                
                // ä¿å­˜å½“å‰éŸ³é¢‘æ•°æ®ç”¨äºPCMä¿å­˜
                currentAudioData = {
                    data: audioBuffer,
                    format: audioData.format,
                    channels: audioData.channels,
                    rate: audioData.rate,
                    chunk: audioData.chunk,
                    size: audioData.size,
                    timestamp: audioData.timestamp,
                    sync_timestamp: audioData.sync_timestamp
                };
                
                // æ›´æ–°éŸ³é¢‘ä¿¡æ¯
                document.getElementById('audioInfo').textContent = `éŸ³é¢‘: ${(audioData.size / 1024).toFixed(1)} KB`;
                
                // console.log(`éŸ³é¢‘æ•°æ®å¤„ç†æˆåŠŸ: ${audioData.format}, ${audioData.channels}å£°é“, ${audioData.rate}Hz, ${audioData.chunk}æ ·æœ¬`);
                // console.log('=== éŸ³é¢‘æ•°æ®å¤„ç†å®Œæˆ ===');
                
            } catch (error) {
                console.error('å¤„ç†éŸ³é¢‘æ•°æ®å¤±è´¥:', error);
            }
        }
        
        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContext.gain = audioContext.createGain();
                audioContext.gain.connect(audioContext.destination);
                audioContext.gain.gain.value = document.getElementById('volumeSlider').value / 100;
                
                // æ£€æŸ¥éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€
                console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–');
                console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€:', audioContext.state);
                console.log('é‡‡æ ·ç‡:', audioContext.sampleRate);
                console.log('å½“å‰éŸ³é‡:', audioContext.gain.gain.value);
                
                // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æš‚åœï¼Œå°è¯•æ¢å¤
                if (audioContext.state === 'suspended') {
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æš‚åœï¼Œå°è¯•æ¢å¤...');
                    audioContext.resume().then(() => {
                        console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤ï¼ŒçŠ¶æ€:', audioContext.state);
                    }).catch(err => {
                        console.error('æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥:', err);
                    });
                }
                
            } catch (error) {
                console.error('åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥:', error);
            }
        }
        
        // æ’­æ”¾éŸ³é¢‘
        function playAudio(audioBuffer) {
            if (!audioContext) {
                console.warn('éŸ³é¢‘ä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œå°è¯•åˆå§‹åŒ–...');
                initAudioContext();
                if (!audioContext) {
                    console.error('æ— æ³•åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡');
                    return;
                }
            }
            
            try {
                // æ£€æŸ¥éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€
                if (audioContext.state === 'suspended') {
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æš‚åœï¼Œå°è¯•æ¢å¤...');
                    audioContext.resume().then(() => {
                        console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤ï¼Œé‡æ–°æ’­æ”¾éŸ³é¢‘');
                        playAudio(audioBuffer); // é€’å½’è°ƒç”¨
                    }).catch(err => {
                        console.error('æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥:', err);
                    });
                    return;
                }
                
                // éªŒè¯éŸ³é¢‘æ•°æ®
                if (!audioBuffer || audioBuffer.byteLength === 0) {
                    console.warn('éŸ³é¢‘æ•°æ®ä¸ºç©ºï¼Œè·³è¿‡æ’­æ”¾');
                    return;
                }
                
                // è·å–éŸ³é¢‘å‚æ•°
                const sourceSampleRate = 48000; // æºéŸ³é¢‘é‡‡æ ·ç‡ï¼ˆä»C++åº”ç”¨è·å–ï¼‰
                const targetSampleRate = audioContext.sampleRate; // ç›®æ ‡é‡‡æ ·ç‡ï¼ˆæµè§ˆå™¨éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼‰
                const channels = 2; // ç«‹ä½“å£°
                const bytesPerSample = 2; // 16ä½
                const samplesPerChannel = audioBuffer.byteLength / (channels * bytesPerSample);
                
                // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
                if (samplesPerChannel <= 0 || !Number.isInteger(samplesPerChannel)) {
                    console.error('éŸ³é¢‘æ•°æ®æ ¼å¼é”™è¯¯:', audioBuffer.byteLength, 'å­—èŠ‚');
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡é‡‡æ ·
                const needsResampling = Math.abs(sourceSampleRate - targetSampleRate) > 1;
                const enableResampling = document.getElementById('enableResampling')?.checked !== false;
                
                if (needsResampling && enableResampling) {
                    console.log(`éœ€è¦é‡é‡‡æ ·: ${sourceSampleRate}Hz â†’ ${targetSampleRate}Hz`);
                    // ä½¿ç”¨é‡é‡‡æ ·æ’­æ”¾
                    playAudioWithResampling(audioBuffer, sourceSampleRate, targetSampleRate, channels);
                    return;
                } else if (needsResampling && !enableResampling) {
                    console.log(`é‡‡æ ·ç‡ä¸åŒ¹é…ä½†é‡é‡‡æ ·å·²ç¦ç”¨: ${sourceSampleRate}Hz vs ${targetSampleRate}Hz`);
                    console.log('âš ï¸ è¿™å¯èƒ½å¯¼è‡´éŸ³é¢‘è´¨é‡é—®é¢˜');
                }
                
                // ç›´æ¥æ’­æ”¾ï¼ˆé‡‡æ ·ç‡åŒ¹é…ï¼‰
                const audioBufferSource = audioContext.createBuffer(channels, samplesPerChannel, targetSampleRate);
                
                // ä»ArrayBufferåˆ›å»ºInt16Arrayè§†å›¾
                const int16View = new Int16Array(audioBuffer);
                
                // å¡«å……éŸ³é¢‘æ•°æ®
                for (let channel = 0; channel < channels; channel++) {
                    const channelData = audioBufferSource.getChannelData(channel);
                    
                    for (let i = 0; i < samplesPerChannel; i++) {
                        // è®¡ç®—åœ¨Int16Arrayä¸­çš„ç´¢å¼•ï¼ˆäº¤é”™æ ¼å¼ï¼šL,R,L,R...ï¼‰
                        const sampleIndex = i * channels + channel;
                        
                        if (sampleIndex < int16View.length) {
                            // å°†16ä½æœ‰ç¬¦å·æ•´æ•°è½¬æ¢ä¸º-1åˆ°1èŒƒå›´çš„æµ®ç‚¹æ•°
                            // æ·»åŠ è½»å¾®çš„å¹³æ»‘å¤„ç†ï¼Œå‡å°‘åˆºå•¦å£°
                            const rawSample = int16View[sampleIndex];
                            const normalizedSample = rawSample / 32768.0;
                            
                            // åº”ç”¨è½»å¾®çš„å¹³æ»‘æ»¤æ³¢
                            channelData[i] = applySmoothingFilter(normalizedSample, i, channel);
                        } else {
                            // æ•°æ®ä¸è¶³æ—¶ç”¨0å¡«å……
                            channelData[i] = 0;
                        }
                    }
                }
                
                // æ’­æ”¾éŸ³é¢‘
                const source = audioContext.createBufferSource();
                source.buffer = audioBufferSource;
                source.connect(audioContext.gain);
                
                // æ·»åŠ é”™è¯¯å¤„ç†
                source.onerror = function(e) {
                    console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                };
                
                source.start();
                
                // console.log(`éŸ³é¢‘æ’­æ”¾æˆåŠŸ: ${samplesPerChannel} æ ·æœ¬, ${channels} å£°é“, ${targetSampleRate}Hz`);
                // console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€:', audioContext.state);
                // console.log('å½“å‰éŸ³é‡:', audioContext.gain.gain.value);
                // console.log('éŸ³é¢‘æ•°æ®èŒƒå›´:', Math.min(...int16View), 'åˆ°', Math.max(...int16View));
                
            } catch (error) {
                console.error('æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
            }
        }
        
        // é‡é‡‡æ ·æ’­æ”¾éŸ³é¢‘
        function playAudioWithResampling(audioBuffer, sourceSampleRate, targetSampleRate, channels) {
            try {
                const bytesPerSample = 2;
                const sourceSamplesPerChannel = audioBuffer.byteLength / (channels * bytesPerSample);
                
                // è®¡ç®—é‡é‡‡æ ·åçš„æ ·æœ¬æ•°
                const resampleRatio = targetSampleRate / sourceSampleRate;
                const targetSamplesPerChannel = Math.round(sourceSamplesPerChannel * resampleRatio);
                
                console.log(`é‡é‡‡æ ·: ${sourceSamplesPerChannel} â†’ ${targetSamplesPerChannel} æ ·æœ¬`);
                
                // åˆ›å»ºç›®æ ‡éŸ³é¢‘ç¼“å†²åŒº
                const audioBufferSource = audioContext.createBuffer(channels, targetSamplesPerChannel, targetSampleRate);
                
                // ä»ArrayBufferåˆ›å»ºInt16Arrayè§†å›¾
                const int16View = new Int16Array(audioBuffer);
                
                // æ‰§è¡Œé‡é‡‡æ ·
                for (let channel = 0; channel < channels; channel++) {
                    const channelData = audioBufferSource.getChannelData(channel);
                    
                    for (let i = 0; i < targetSamplesPerChannel; i++) {
                        // è®¡ç®—æºéŸ³é¢‘ä¸­çš„å¯¹åº”ä½ç½®
                        const sourceIndex = i / resampleRatio;
                        const sourceIndexFloor = Math.floor(sourceIndex);
                        const sourceIndexCeil = Math.min(sourceIndexFloor + 1, sourceSamplesPerChannel - 1);
                        const fraction = sourceIndex - sourceIndexFloor;
                        
                        // è·å–æºéŸ³é¢‘æ ·æœ¬
                        let sample1 = 0, sample2 = 0;
                        
                        if (sourceIndexFloor < sourceSamplesPerChannel) {
                            const index1 = sourceIndexFloor * channels + channel;
                            if (index1 < int16View.length) {
                                sample1 = int16View[index1] / 32768.0;
                            }
                        }
                        
                        if (sourceIndexCeil < sourceSamplesPerChannel) {
                            const index2 = sourceIndexCeil * channels + channel;
                            if (index2 < int16View.length) {
                                sample2 = int16View[index2] / 32768.0;
                            }
                        }
                        
                        // çº¿æ€§æ’å€¼é‡é‡‡æ ·
                        const interpolatedSample = sample1 * (1 - fraction) + sample2 * fraction;
                        
                        // åº”ç”¨å¹³æ»‘æ»¤æ³¢
                        channelData[i] = applySmoothingFilter(interpolatedSample, i, channel);
                    }
                }
                
                // æ’­æ”¾éŸ³é¢‘
                const source = audioContext.createBufferSource();
                source.buffer = audioBufferSource;
                source.connect(audioContext.gain);
                
                source.onerror = function(e) {
                    console.error('é‡é‡‡æ ·éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                };
                
                source.start();
                
                console.log(`é‡é‡‡æ ·éŸ³é¢‘æ’­æ”¾æˆåŠŸ: ${targetSamplesPerChannel} æ ·æœ¬, ${channels} å£°é“, ${targetSampleRate}Hz`);
                
            } catch (error) {
                console.error('é‡é‡‡æ ·æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
                // å¦‚æœé‡é‡‡æ ·å¤±è´¥ï¼Œå°è¯•ç›´æ¥æ’­æ”¾
                console.log('é‡é‡‡æ ·å¤±è´¥ï¼Œå°è¯•ç›´æ¥æ’­æ”¾...');
                playAudioDirect(audioBuffer);
            }
        }
        
        // ç›´æ¥æ’­æ”¾éŸ³é¢‘ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
        function playAudioDirect(audioBuffer) {
            try {
                const channels = 2;
                const bytesPerSample = 2;
                const samplesPerChannel = audioBuffer.byteLength / (channels * bytesPerSample);
                
                const audioBufferSource = audioContext.createBuffer(channels, samplesPerChannel, audioContext.sampleRate);
                const int16View = new Int16Array(audioBuffer);
                
                for (let channel = 0; channel < channels; channel++) {
                    const channelData = audioBufferSource.getChannelData(channel);
                    
                    for (let i = 0; i < samplesPerChannel; i++) {
                        const sampleIndex = i * channels + channel;
                        
                        if (sampleIndex < int16View.length) {
                            channelData[i] = int16View[sampleIndex] / 32768.0;
                        } else {
                            channelData[i] = 0;
                        }
                    }
                }
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBufferSource;
                source.connect(audioContext.gain);
                source.start();
                
                console.log(`ç›´æ¥æ’­æ”¾éŸ³é¢‘æˆåŠŸ: ${samplesPerChannel} æ ·æœ¬`);
                
            } catch (error) {
                console.error('ç›´æ¥æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
            }
        }
        
        // åº”ç”¨å¹³æ»‘æ»¤æ³¢ï¼Œå‡å°‘åˆºå•¦å£°
        function applySmoothingFilter(sample, index, channel) {
            // æ£€æŸ¥æ˜¯å¦å¯ç”¨å¹³æ»‘æ»¤æ³¢
            const enableSmoothing = document.getElementById('enableSmoothing')?.checked !== false;
            if (!enableSmoothing) {
                return sample; // ç›´æ¥è¿”å›åŸå§‹æ ·æœ¬
            }
            
            // è·å–æ»¤æ³¢å¼ºåº¦è®¾ç½®
            const filterStrength = parseInt(document.getElementById('filterStrength')?.value || '3');
            const bufferSize = Math.max(2, Math.min(8, filterStrength + 2)); // 2-8ä¹‹é—´çš„ç¼“å†²åŒºå¤§å°
            
            // ç®€å•çš„ç§»åŠ¨å¹³å‡æ»¤æ³¢
            if (!window.audioFilterBuffer) {
                window.audioFilterBuffer = {};
            }
            
            const key = `${channel}_${index % bufferSize}`; // åŠ¨æ€ç¼“å†²åŒºå¤§å°
            if (!window.audioFilterBuffer[key]) {
                window.audioFilterBuffer[key] = [];
            }
            
            const buffer = window.audioFilterBuffer[key];
            buffer.push(sample);
            
            // ä¿æŒç¼“å†²åŒºå¤§å°
            if (buffer.length > bufferSize) {
                buffer.shift();
            }
            
            // è®¡ç®—å¹³å‡å€¼
            const avgSample = buffer.reduce((sum, val) => sum + val, 0) / buffer.length;
            
            // æ£€æŸ¥æ˜¯å¦å¯ç”¨åŠ¨æ€å‹ç¼©
            const enableCompression = document.getElementById('enableCompression')?.checked !== false;
            
            if (enableCompression) {
                // åº”ç”¨åŠ¨æ€å‹ç¼©ï¼Œå‡å°‘è¿‡å¤§çš„æŒ¯å¹…
                const compressionRatio = 0.8 - (filterStrength * 0.1); // æ ¹æ®æ»¤æ³¢å¼ºåº¦è°ƒæ•´å‹ç¼©
                const compressedSample = Math.tanh(avgSample * compressionRatio) * (0.9 - filterStrength * 0.05);
                return compressedSample;
            } else {
                // åªåº”ç”¨å¹³æ»‘æ»¤æ³¢ï¼Œä¸å‹ç¼©
                return avgSample;
            }
        }
        
        // å¤„ç†è§†é¢‘åŒæ­¥
        function processVideoSync(frameData) {
            const currentTime = Date.now();
            const syncTimestamp = frameData.sync_timestamp * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
            const frameIndex = frameData.frame_index;
            
            // è®¡ç®—åŒæ­¥åç§»
            const syncOffset = Math.abs(currentTime - syncTimestamp);
            syncOffsets.push(syncOffset);
            
            // ä¿æŒæœ€è¿‘100ä¸ªåç§»å€¼
            if (syncOffsets.length > 100) {
                syncOffsets.shift();
            }
            
            // æ›´æ–°åŒæ­¥çŠ¶æ€
            updateSyncStatus(syncOffset);
            
            // æ›´æ–°åŒæ­¥åç§»æ˜¾ç¤º
            document.getElementById('syncOffset').textContent = `${syncOffset.toFixed(1)} ms`;
        }
        
        // å¤„ç†éŸ³é¢‘åŒæ­¥
        function processAudioSync(audioData) {
            const currentTime = Date.now();
            const syncTimestamp = audioData.sync_timestamp * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
            
            // è®¡ç®—éŸ³é¢‘åŒæ­¥åç§»
            const audioSyncOffset = Math.abs(currentTime - syncTimestamp);
            
            // æ›´æ–°åŒæ­¥çŠ¶æ€ï¼ˆå–è§†é¢‘å’ŒéŸ³é¢‘åç§»çš„å¹³å‡å€¼ï¼‰
            const avgOffset = (audioSyncOffset + (syncOffsets[syncOffsets.length - 1] || 0)) / 2;
            updateSyncStatus(avgOffset);
        }
        
        // æ›´æ–°åŒæ­¥çŠ¶æ€
        function updateSyncStatus(syncOffset) {
            const syncStatus = document.getElementById('syncStatus');
            
            if (syncOffset < syncThreshold) {
                syncStatus.textContent = 'âœ… åŒæ­¥è‰¯å¥½';
                syncStatus.className = 'sync-status sync-good';
            } else if (syncOffset < syncThreshold * 2) {
                syncStatus.textContent = 'âš ï¸ åŒæ­¥ä¸€èˆ¬';
                syncStatus.className = 'sync-status sync-warning';
            } else {
                syncStatus.textContent = 'âŒ åŒæ­¥è¾ƒå·®';
                syncStatus.className = 'sync-status sync-bad';
            }
        }
        
        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.className = `status ${status}`;
            statusElement.textContent = message;
        }
        
        // é‡ç½®ç»Ÿè®¡ä¿¡æ¯
        function resetStats() {
            totalFrames = 0;
            frameCount = 0;
            totalDataSize = 0;
            latencySum = 0;
            latencyCount = 0;
            syncOffsets = [];
            
            // é‡ç½®æ˜¾ç¤º
            document.getElementById('totalFrames').textContent = '0';
            document.getElementById('currentFps').textContent = '0.0';
            document.getElementById('dataSize').textContent = '0 KB';
            document.getElementById('avgLatency').textContent = '0 ms';
            document.getElementById('syncOffset').textContent = '0 ms';
            document.getElementById('bufferHealth').textContent = '100%';
            
            document.getElementById('audioInfo').textContent = 'éŸ³é¢‘: æœªæ¥æ”¶';
            document.getElementById('videoInfo').textContent = 'è§†é¢‘: æœªæ¥æ”¶';
        }
        
        // å¯åŠ¨å¿ƒè·³æ£€æµ‹
        function startHeartbeat() {
            setInterval(function() {
                if (isConnected && websocket) {
                    websocket.send(JSON.stringify({
                        type: 'ping',
                        timestamp: Date.now()
                    }));
                }
            }, 30000); // æ¯30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
        }
        
        // å¯åŠ¨FPSè®¡æ•°å™¨
        function startFpsCounter() {
            setInterval(function() {
                const currentTime = Date.now();
                const timeDiff = (currentTime - lastFpsTime) / 1000;
                
                if (timeDiff > 0) {
                    const fps = frameCount / timeDiff;
                    document.getElementById('currentFps').textContent = fps.toFixed(1);
                    document.getElementById('fps').textContent = fps.toFixed(1);
                    
                    // è®¡ç®—å¹³å‡å»¶è¿Ÿ
                    if (latencyCount > 0) {
                        const avgLatency = latencySum / latencyCount;
                        document.getElementById('avgLatency').textContent = `${avgLatency.toFixed(1)} ms`;
                        document.getElementById('latency').textContent = `${avgLatency.toFixed(1)} ms`;
                    }
                    
                    // è®¡ç®—æ•°æ®å¤§å°
                    const dataSizeKB = totalDataSize / 1024;
                    if (dataSizeKB > 1024) {
                        document.getElementById('dataSize').textContent = `${(dataSizeKB / 1024).toFixed(1)} MB`;
                    } else {
                        document.getElementById('dataSize').textContent = `${dataSizeKB.toFixed(1)} KB`;
                    }
                    
                    // è®¡ç®—ç¼“å†²åŒºå¥åº·åº¦
                    const bufferHealth = Math.max(0, 100 - (syncOffsets.length > 0 ? Math.max(...syncOffsets) / 10 : 0));
                    document.getElementById('bufferHealth').textContent = `${Math.min(100, bufferHealth).toFixed(0)}%`;
                    
                    // æ›´æ–°è§†é¢‘ä¿¡æ¯
                    document.getElementById('videoInfo').textContent = `è§†é¢‘: ${frameCount} å¸§`;
                }
                
                // é‡ç½®è®¡æ•°å™¨
                frameCount = 0;
                lastFpsTime = currentTime;
                latencySum = 0;
                latencyCount = 0;
                
            }, 1000); // æ¯ç§’æ›´æ–°ä¸€æ¬¡
        }
        
        // å·¥å…·å‡½æ•°ï¼šbase64è½¬ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // æµ‹è¯•éŸ³é¢‘ç›¸å…³å˜é‡
        let testAudioSource = null;
        let testAudioInterval = null;
        
        // æ’­æ”¾æµ‹è¯•éŸ³è°ƒ
        function playTestTone() {
            if (!audioContext) {
                initAudioContext();
            }
            
            try {
                stopTestAudio(); // åœæ­¢ä¹‹å‰çš„æµ‹è¯•éŸ³é¢‘
                
                const frequency = 440; // A4éŸ³è°ƒ (440Hz)
                const duration = 3; // 3ç§’
                const sampleRate = audioContext.sampleRate;
                const samples = Math.floor(sampleRate * duration);
                
                // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº
                const buffer = audioContext.createBuffer(2, samples, sampleRate);
                
                // ç”Ÿæˆæ­£å¼¦æ³¢
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    for (let i = 0; i < samples; i++) {
                        // ç”Ÿæˆæ­£å¼¦æ³¢ï¼Œæ·»åŠ æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                        const fadeIn = Math.min(1, i / (sampleRate * 0.1)); // 0.1ç§’æ·¡å…¥
                        const fadeOut = Math.min(1, (samples - i) / (sampleRate * 0.1)); // 0.1ç§’æ·¡å‡º
                        const fade = Math.min(fadeIn, fadeOut);
                        
                        channelData[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 0.3 * fade;
                    }
                }
                
                // æ’­æ”¾éŸ³é¢‘
                testAudioSource = audioContext.createBufferSource();
                testAudioSource.buffer = buffer;
                testAudioSource.connect(audioContext.gain);
                testAudioSource.start();
                
                console.log(`æµ‹è¯•éŸ³è°ƒæ’­æ”¾æˆåŠŸ: ${frequency}Hz, ${duration}ç§’`);
                
                // è‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    if (testAudioSource) {
                        testAudioSource.stop();
                        testAudioSource = null;
                    }
                }, duration * 1000);
                
            } catch (error) {
                console.error('æ’­æ”¾æµ‹è¯•éŸ³è°ƒå¤±è´¥:', error);
            }
        }
        
        // æ’­æ”¾æ‰«é¢‘éŸ³
        function playTestSweep() {
            if (!audioContext) {
                initAudioContext();
            }
            
            try {
                stopTestAudio(); // åœæ­¢ä¹‹å‰çš„æµ‹è¯•éŸ³é¢‘
                
                const startFreq = 20; // èµ·å§‹é¢‘ç‡ 20Hz
                const endFreq = 20000; // ç»“æŸé¢‘ç‡ 20kHz
                const duration = 5; // 5ç§’
                const sampleRate = audioContext.sampleRate;
                const samples = Math.floor(sampleRate * duration);
                
                // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº
                const buffer = audioContext.createBuffer(2, samples, sampleRate);
                
                // ç”Ÿæˆæ‰«é¢‘éŸ³
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    for (let i = 0; i < samples; i++) {
                        // è®¡ç®—å½“å‰é¢‘ç‡ï¼ˆå¯¹æ•°æ‰«é¢‘ï¼‰
                        const progress = i / samples;
                        const currentFreq = startFreq * Math.pow(endFreq / startFreq, progress);
                        
                        // ç”Ÿæˆæ­£å¼¦æ³¢
                        const phase = 2 * Math.PI * currentFreq * i / sampleRate;
                        channelData[i] = Math.sin(phase) * 0.2;
                    }
                }
                
                // æ’­æ”¾éŸ³é¢‘
                testAudioSource = audioContext.createBufferSource();
                testAudioSource.buffer = buffer;
                testAudioSource.connect(audioContext.gain);
                testAudioSource.start();
                
                console.log(`æ‰«é¢‘éŸ³æ’­æ”¾æˆåŠŸ: ${startFreq}Hz â†’ ${endFreq}Hz, ${duration}ç§’`);
                
                // è‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    if (testAudioSource) {
                        testAudioSource.stop();
                        testAudioSource = null;
                    }
                }, duration * 1000);
                
            } catch (error) {
                console.error('æ’­æ”¾æ‰«é¢‘éŸ³å¤±è´¥:', error);
            }
        }
        
        // åœæ­¢æµ‹è¯•éŸ³é¢‘
        function stopTestAudio() {
            try {
                if (testAudioSource) {
                    testAudioSource.stop();
                    testAudioSource = null;
                }
                
                if (testAudioInterval) {
                    clearInterval(testAudioInterval);
                    testAudioInterval = null;
                }
                
                console.log('æµ‹è¯•éŸ³é¢‘å·²åœæ­¢');
                
            } catch (error) {
                console.error('åœæ­¢æµ‹è¯•éŸ³é¢‘å¤±è´¥:', error);
            }
        }
        
        // æ’­æ”¾ç™½å™ªå£°ï¼ˆç”¨äºæµ‹è¯•éŸ³é¢‘ç³»ç»Ÿï¼‰
        function playWhiteNoise() {
            if (!audioContext) {
                initAudioContext();
            }
            
            try {
                stopTestAudio();
                
                const duration = 2; // 2ç§’
                const sampleRate = audioContext.sampleRate;
                const samples = Math.floor(sampleRate * duration);
                
                // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº
                const buffer = audioContext.createBuffer(2, samples, sampleRate);
                
                // ç”Ÿæˆç™½å™ªå£°
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    for (let i = 0; i < samples; i++) {
                        // ç”Ÿæˆ-0.1åˆ°0.1ä¹‹é—´çš„éšæœºå€¼
                        channelData[i] = (Math.random() - 0.5) * 0.2;
                    }
                }
                
                // æ’­æ”¾éŸ³é¢‘
                testAudioSource = audioContext.createBufferSource();
                testAudioSource.buffer = buffer;
                testAudioSource.connect(audioContext.gain);
                testAudioSource.start();
                
                console.log(`ç™½å™ªå£°æ’­æ”¾æˆåŠŸ: ${duration}ç§’`);
                
                // è‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    if (testAudioSource) {
                        testAudioSource.stop();
                        testAudioSource = null;
                    }
                }, duration * 1000);
                
            } catch (error) {
                console.error('æ’­æ”¾ç™½å™ªå£°å¤±è´¥:', error);
            }
        }
        
        // éŸ³é¢‘è¯Šæ–­åŠŸèƒ½
        function diagnoseAudio() {
            console.log('=== éŸ³é¢‘ç³»ç»Ÿè¯Šæ–­ ===');
            
            // æ£€æŸ¥Web Audio APIæ”¯æŒ
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                console.log('âœ… Web Audio API æ”¯æŒæ­£å¸¸');
            } else {
                console.error('âŒ Web Audio API ä¸æ”¯æŒ');
                return;
            }
            
            // æ£€æŸ¥éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (audioContext) {
                console.log('âœ… éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆ›å»º');
                console.log('   - çŠ¶æ€:', audioContext.state);
                console.log('   - é‡‡æ ·ç‡:', audioContext.sampleRate);
                console.log('   - å½“å‰æ—¶é—´:', audioContext.currentTime);
                
                // æ£€æŸ¥éŸ³é‡è®¾ç½®
                if (audioContext.gain) {
                    console.log('   - éŸ³é‡å¢ç›Š:', audioContext.gain.gain.value);
                }
                
                // æ£€æŸ¥è¿æ¥çŠ¶æ€
                if (audioContext.destination) {
                    console.log('   - éŸ³é¢‘è¾“å‡ºç›®æ ‡:', audioContext.destination);
                }
            } else {
                console.log('âš ï¸ éŸ³é¢‘ä¸Šä¸‹æ–‡æœªåˆ›å»º');
            }
            
            // æ£€æŸ¥æµè§ˆå™¨éŸ³é¢‘æƒé™
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'microphone' }).then(result => {
                    console.log('   - éº¦å…‹é£æƒé™:', result.state);
                });
            }
            
            // æ£€æŸ¥ç”¨æˆ·äº¤äº’çŠ¶æ€
            console.log('   - é¡µé¢å¯è§æ€§:', document.visibilityState);
            console.log('   - é¡µé¢ç„¦ç‚¹:', document.hasFocus());
            
            // å°è¯•æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (audioContext && audioContext.state === 'suspended') {
                console.log('ğŸ”„ å°è¯•æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡...');
                audioContext.resume().then(() => {
                    console.log('âœ… éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤ï¼ŒçŠ¶æ€:', audioContext.state);
                }).catch(err => {
                    console.error('âŒ æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥:', err);
                });
            }
            
            // æ£€æŸ¥éŸ³é‡æ»‘å—
            const volumeSlider = document.getElementById('volumeSlider');
            if (volumeSlider) {
                console.log('   - éŸ³é‡æ»‘å—å€¼:', volumeSlider.value + '%');
            }
            
            // æ£€æŸ¥å½“å‰éŸ³é¢‘æ•°æ®
            if (currentAudioData) {
                console.log('ğŸ“Š å½“å‰éŸ³é¢‘æ•°æ®åˆ†æ:');
                console.log('   - æ ¼å¼:', currentAudioData.format);
                console.log('   - é‡‡æ ·ç‡:', currentAudioData.rate, 'Hz');
                console.log('   - å£°é“æ•°:', currentAudioData.channels);
                console.log('   - æ•°æ®å¤§å°:', currentAudioData.size, 'å­—èŠ‚');
                console.log('   - æ ·æœ¬æ•°:', currentAudioData.chunk);
                
                // åˆ†æéŸ³é¢‘æ•°æ®è´¨é‡
                analyzeAudioQuality(currentAudioData);
            } else {
                console.log('âš ï¸ æ²¡æœ‰å¯åˆ†æçš„éŸ³é¢‘æ•°æ®');
            }
            
            // æ£€æŸ¥é‡‡æ ·ç‡åŒ¹é…
            if (audioContext) {
                const sourceRate = 48000; // C++åº”ç”¨çš„é‡‡æ ·ç‡
                const targetRate = audioContext.sampleRate;
                const rateDiff = Math.abs(sourceRate - targetRate);
                
                console.log('ğŸµ é‡‡æ ·ç‡åˆ†æ:');
                console.log('   - æºéŸ³é¢‘é‡‡æ ·ç‡:', sourceRate, 'Hz');
                console.log('   - ç›®æ ‡é‡‡æ ·ç‡:', targetRate, 'Hz');
                console.log('   - å·®å¼‚:', rateDiff, 'Hz');
                
                if (rateDiff > 1) {
                    console.log('âš ï¸ é‡‡æ ·ç‡ä¸åŒ¹é…ï¼Œå¯èƒ½å¯¼è‡´éŸ³é¢‘è´¨é‡é—®é¢˜');
                    console.log('ğŸ’¡ å»ºè®®: å¯ç”¨é‡é‡‡æ ·åŠŸèƒ½');
                } else {
                    console.log('âœ… é‡‡æ ·ç‡åŒ¹é…è‰¯å¥½');
                }
            }
            
            console.log('=== è¯Šæ–­å®Œæˆ ===');
        }
        
        // åˆ†æéŸ³é¢‘æ•°æ®è´¨é‡
        function analyzeAudioQuality(audioData) {
            try {
                if (!audioData.data) {
                    console.log('âŒ æ— æ³•åˆ†æéŸ³é¢‘æ•°æ®è´¨é‡ï¼šæ•°æ®ä¸ºç©º');
                    return;
                }
                
                const audioBuffer = audioData.data;
                const int16View = new Int16Array(audioBuffer);
                
                // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
                const minValue = Math.min(...int16View);
                const maxValue = Math.max(...int16View);
                const avgValue = int16View.reduce((sum, val) => sum + Math.abs(val), 0) / int16View.length;
                
                console.log('ğŸ“ˆ éŸ³é¢‘æ•°æ®è´¨é‡åˆ†æ:');
                console.log('   - æ•°æ®èŒƒå›´:', minValue, 'åˆ°', maxValue);
                console.log('   - å¹³å‡ç»å¯¹å€¼:', avgValue.toFixed(2));
                console.log('   - åŠ¨æ€èŒƒå›´:', (maxValue - minValue));
                
                // æ£€æµ‹æ½œåœ¨çš„éŸ³é¢‘é—®é¢˜
                const zeroCount = int16View.filter(val => val === 0).length;
                const zeroRatio = (zeroCount / int16View.length) * 100;
                
                console.log('   - é›¶å€¼æ ·æœ¬æ¯”ä¾‹:', zeroRatio.toFixed(2) + '%');
                
                if (zeroRatio > 50) {
                    console.log('âš ï¸ è­¦å‘Š: é›¶å€¼æ ·æœ¬è¿‡å¤šï¼Œå¯èƒ½å¯¼è‡´éŸ³é¢‘é™éŸ³æˆ–å¤±çœŸ');
                }
                
                // æ£€æµ‹å‰Šæ³¢
                const clippingThreshold = 32000; // æ¥è¿‘16ä½æœ€å¤§å€¼
                const clippingCount = int16View.filter(val => Math.abs(val) > clippingThreshold).length;
                const clippingRatio = (clippingCount / int16View.length) * 100;
                
                console.log('   - å‰Šæ³¢æ ·æœ¬æ¯”ä¾‹:', clippingRatio.toFixed(2) + '%');
                
                if (clippingRatio > 5) {
                    console.log('âš ï¸ è­¦å‘Š: å‰Šæ³¢æ ·æœ¬è¿‡å¤šï¼Œå¯èƒ½å¯¼è‡´éŸ³é¢‘å¤±çœŸ');
                }
                
                // æ£€æµ‹å™ªå£°
                const noiseThreshold = 100;
                const noiseCount = int16View.filter(val => Math.abs(val) < noiseThreshold && val !== 0).length;
                const noiseRatio = (noiseCount / int16View.length) * 100;
                
                console.log('   - ä½ç”µå¹³å™ªå£°æ¯”ä¾‹:', noiseRatio.toFixed(2) + '%');
                
                if (noiseRatio > 30) {
                    console.log('âš ï¸ è­¦å‘Š: ä½ç”µå¹³å™ªå£°è¿‡å¤šï¼Œå¯èƒ½å½±å“éŸ³é¢‘è´¨é‡');
                }
                
                // æ€»ä½“è´¨é‡è¯„ä¼°
                let qualityScore = 100;
                if (zeroRatio > 50) qualityScore -= 30;
                if (clippingRatio > 5) qualityScore -= 25;
                if (noiseRatio > 30) qualityScore -= 20;
                if (Math.abs(audioData.rate - 48000) > 1) qualityScore -= 15;
                
                qualityScore = Math.max(0, qualityScore);
                
                console.log('ğŸ† éŸ³é¢‘è´¨é‡è¯„åˆ†:', qualityScore + '/100');
                
                if (qualityScore >= 80) {
                    console.log('âœ… éŸ³é¢‘è´¨é‡è‰¯å¥½');
                } else if (qualityScore >= 60) {
                    console.log('âš ï¸ éŸ³é¢‘è´¨é‡ä¸€èˆ¬ï¼Œå»ºè®®æ£€æŸ¥');
                } else {
                    console.log('âŒ éŸ³é¢‘è´¨é‡è¾ƒå·®ï¼Œéœ€è¦ä¼˜åŒ–');
                }
                
            } catch (error) {
                console.error('åˆ†æéŸ³é¢‘è´¨é‡å¤±è´¥:', error);
            }
        }
        
        // éŸ³é¢‘å½•åˆ¶åŠŸèƒ½
        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
        
        function startRecording() {
            if (!audioEnabled) {
                alert('è¯·å…ˆå¯åŠ¨éŸ³é¢‘æ•è·');
                return;
            }
            
            isRecording = true;
            recordedChunks = [];
            
            document.getElementById('recordButton').textContent = 'â¹ï¸ åœæ­¢å½•åˆ¶';
            document.getElementById('recordButton').className = 'btn-danger';
            document.getElementById('recordingStatus').textContent = 'å½•åˆ¶ä¸­...';
            document.getElementById('recordingStatus').style.color = '#dc3545';
            document.getElementById('recordingInfo').textContent = '';
            
            console.log('éŸ³é¢‘å½•åˆ¶å·²å¼€å§‹');
        }
        
        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            
            document.getElementById('recordButton').textContent = 'ğŸ™ï¸ å¼€å§‹å½•åˆ¶';
            document.getElementById('recordButton').className = 'btn-primary';
            document.getElementById('recordingStatus').textContent = 'å½•åˆ¶å®Œæˆ';
            document.getElementById('recordingStatus').style.color = '#28a745';
            
            if (recordedChunks.length > 0) {
                downloadWAV();
            } else {
                alert('æ²¡æœ‰å½•åˆ¶åˆ°éŸ³é¢‘æ•°æ®');
            }
            
            console.log('éŸ³é¢‘å½•åˆ¶å·²åœæ­¢');
        }
        
        function downloadWAV() {
            try {
                if (recordedChunks.length === 0) {
                    throw new Error('æ²¡æœ‰éŸ³é¢‘æ•°æ®');
                }
                
                // è·å–ç¬¬ä¸€ä¸ªéŸ³é¢‘å—çš„å‚æ•°
                const firstChunk = recordedChunks[0];
                const sampleRate = firstChunk.rate || 48000;
                const channels = firstChunk.channels || 2;
                const bytesPerSample = 2; // 16ä½
                
                // éªŒè¯æ‰€æœ‰éŸ³é¢‘å—çš„å‚æ•°ä¸€è‡´æ€§
                let totalSamples = 0;
                let totalBytes = 0;
                let isConsistent = true;
                
                recordedChunks.forEach((chunk, index) => {
                    if (chunk.rate !== sampleRate || chunk.channels !== channels) {
                        console.warn(`éŸ³é¢‘å— ${index} å‚æ•°ä¸ä¸€è‡´: é‡‡æ ·ç‡ ${chunk.rate}Hz vs ${sampleRate}Hz, å£°é“æ•° ${chunk.channels} vs ${channels}`);
                        isConsistent = false;
                    }
                    
                    totalSamples += chunk.chunk || 0;
                    totalBytes += chunk.data.byteLength;
                });
                
                if (!isConsistent) {
                    console.warn('æ£€æµ‹åˆ°éŸ³é¢‘å‚æ•°ä¸ä¸€è‡´ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªéŸ³é¢‘å—çš„å‚æ•°');
                }
                
                // éªŒè¯æ ·æœ¬æ•°è®¡ç®—
                const expectedBytes = totalSamples * channels * bytesPerSample;
                if (Math.abs(totalBytes - expectedBytes) > 100) { // å…è®¸100å­—èŠ‚çš„è¯¯å·®
                    console.warn(`éŸ³é¢‘æ•°æ®å¤§å°ä¸åŒ¹é…: æœŸæœ› ${expectedBytes} å­—èŠ‚, å®é™… ${totalBytes} å­—èŠ‚`);
                }
                
                console.log(`WAVæ–‡ä»¶å‚æ•°: ${sampleRate}Hz, ${channels}å£°é“, ${totalSamples}æ ·æœ¬, ${totalBytes}å­—èŠ‚`);
                
                // åˆ›å»ºWAVæ–‡ä»¶å¤´
                const wavHeader = createWAVHeader(totalSamples, channels, sampleRate, bytesPerSample);
                
                // åˆå¹¶éŸ³é¢‘æ•°æ®
                const wavData = new ArrayBuffer(wavHeader.byteLength + totalBytes);
                const wavView = new Uint8Array(wavData);
                
                // å†™å…¥WAVå¤´
                wavView.set(new Uint8Array(wavHeader), 0);
                
                // å†™å…¥éŸ³é¢‘æ•°æ®
                let dataOffset = wavHeader.byteLength;
                recordedChunks.forEach(chunk => {
                    const chunkView = new Uint8Array(chunk.data);
                    wavView.set(chunkView, dataOffset);
                    dataOffset += chunkView.byteLength;
                });
                
                // ä¸‹è½½æ–‡ä»¶
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `audio_recording_${timestamp}.wav`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                
                console.log(`WAVæ–‡ä»¶å·²ä¸‹è½½: ${filename}`);
                alert(`éŸ³é¢‘å½•åˆ¶å·²ä¿å­˜ä¸º: ${filename}`);
                
            } catch (error) {
                console.error('ç”ŸæˆWAVæ–‡ä»¶å¤±è´¥:', error);
                alert('ç”ŸæˆWAVæ–‡ä»¶å¤±è´¥: ' + error.message);
            }
        }
        
        function createWAVHeader(samples, channels, sampleRate, bytesPerSample) {
            const dataSize = samples * channels * bytesPerSample;
            const headerSize = 44;
            const totalSize = headerSize + dataSize - 8;
            
            const header = new ArrayBuffer(headerSize);
            const view = new DataView(header);
            
            // RIFFæ ‡è¯†
            view.setUint32(0, 0x52494646, false); // "RIFF"
            view.setUint32(4, totalSize, true);    // æ–‡ä»¶å¤§å°
            view.setUint32(8, 0x57415645, false);  // "WAVE"
            
            // fmtå­å—
            view.setUint32(12, 0x666D7420, false); // "fmt "
            view.setUint32(16, 16, true);           // fmtå­å—å¤§å°
            view.setUint16(20, 1, true);            // éŸ³é¢‘æ ¼å¼ (PCM)
            view.setUint16(22, channels, true);     // å£°é“æ•°
            view.setUint32(24, sampleRate, true);   // é‡‡æ ·ç‡
            view.setUint32(28, sampleRate * channels * bytesPerSample, true); // å­—èŠ‚ç‡
            view.setUint16(32, channels * bytesPerSample, true);             // å—å¯¹é½
            view.setUint16(34, bytesPerSample * 8, true);                    // ä½æ·±åº¦
            
            // dataå­å—
            view.setUint32(36, 0x64617461, false); // "data"
            view.setUint32(40, dataSize, true);     // éŸ³é¢‘æ•°æ®å¤§å°
            
            return header;
        }
        
        // PCMæ–‡ä»¶ä¿å­˜åŠŸèƒ½
        function saveCurrentAudioToPcm() {
            try {
                if (!currentAudioData || !currentAudioData.data) {
                    alert('æ²¡æœ‰å¯ä¿å­˜çš„éŸ³é¢‘æ•°æ®ï¼Œè¯·å…ˆæ¥æ”¶ä¸€äº›éŸ³é¢‘æ•°æ®');
                    return;
                }
                
                console.log('å¼€å§‹ä¿å­˜PCMæ–‡ä»¶...');
                console.log('éŸ³é¢‘æ•°æ®ä¿¡æ¯:', {
                    format: currentAudioData.format,
                    channels: currentAudioData.channels,
                    rate: currentAudioData.rate,
                    chunk: currentAudioData.chunk,
                    size: currentAudioData.size,
                    timestamp: currentAudioData.timestamp
                });
                
                // éªŒè¯éŸ³é¢‘æ•°æ®
                if (currentAudioData.format !== 'pcm') {
                    alert('åªæ”¯æŒä¿å­˜PCMæ ¼å¼çš„éŸ³é¢‘æ•°æ®');
                    return;
                }
                
                // è·å–éŸ³é¢‘å‚æ•°
                const audioBuffer = currentAudioData.data;
                const channels = currentAudioData.channels || 2;
                const sampleRate = currentAudioData.rate || 48000;
                const bytesPerSample = 2; // 16ä½
                
                // è®¡ç®—å®é™…çš„æ ·æœ¬æ•°
                const actualSamples = audioBuffer.byteLength / (channels * bytesPerSample);
                
                console.log(`PCMæ–‡ä»¶å‚æ•°: ${sampleRate}Hz, ${channels}å£°é“, ${actualSamples}æ ·æœ¬, ${audioBuffer.byteLength}å­—èŠ‚`);
                
                // åˆ›å»ºPCMæ–‡ä»¶ï¼ˆçº¯éŸ³é¢‘æ•°æ®ï¼Œæ— æ–‡ä»¶å¤´ï¼‰
                const pcmData = new Uint8Array(audioBuffer);
                
                // ä¸‹è½½PCMæ–‡ä»¶
                const blob = new Blob([pcmData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `audio_pcm_${sampleRate}Hz_${channels}ch_${timestamp}.pcm`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                
                // æ›´æ–°çŠ¶æ€
                document.getElementById('pcmStatus').textContent = 'å·²ä¿å­˜';
                document.getElementById('pcmStatus').style.color = '#28a745';
                
                console.log(`PCMæ–‡ä»¶å·²ä¿å­˜: ${filename}`);
                alert(`PCMæ–‡ä»¶å·²ä¿å­˜ä¸º: ${filename}\n\næ–‡ä»¶ä¿¡æ¯:\né‡‡æ ·ç‡: ${sampleRate}Hz\nå£°é“æ•°: ${channels}\næ ·æœ¬æ•°: ${actualSamples}\næ•°æ®å¤§å°: ${(audioBuffer.byteLength / 1024).toFixed(1)} KB`);
                
                // 3ç§’åé‡ç½®çŠ¶æ€
                setTimeout(() => {
                    document.getElementById('pcmStatus').textContent = 'æœªä¿å­˜';
                    document.getElementById('pcmStatus').style.color = '#666';
                }, 3000);
                
            } catch (error) {
                console.error('ä¿å­˜PCMæ–‡ä»¶å¤±è´¥:', error);
                alert('ä¿å­˜PCMæ–‡ä»¶å¤±è´¥: ' + error.message);
                
                // æ›´æ–°çŠ¶æ€
                document.getElementById('pcmStatus').textContent = 'ä¿å­˜å¤±è´¥';
                document.getElementById('pcmStatus').style.color = '#dc3545';
                
                // 3ç§’åé‡ç½®çŠ¶æ€
                setTimeout(() => {
                    document.getElementById('pcmStatus').textContent = 'æœªä¿å­˜';
                    document.getElementById('pcmStatus').style.color = '#666';
                }, 3000);
            }
        }
        
        // è¿ç»­PCMä¿å­˜åŠŸèƒ½
        function toggleContinuousPcmSave() {
            if (continuousPcmSave) {
                stopContinuousPcmSave();
            } else {
                startContinuousPcmSave();
            }
        }
        
        function startContinuousPcmSave() {
            if (!audioEnabled) {
                alert('è¯·å…ˆå¯åŠ¨éŸ³é¢‘æ•è·');
                return;
            }
            
            continuousPcmSave = true;
            continuousPcmChunks = [];
            continuousPcmStartTime = Date.now();
            
            document.getElementById('continuousPcmButton').textContent = 'â¹ï¸ åœæ­¢è¿ç»­ä¿å­˜';
            document.getElementById('continuousPcmButton').className = 'btn-danger';
            document.getElementById('continuousPcmStatus').textContent = 'å·²å¯åŠ¨';
            document.getElementById('continuousPcmStatus').style.color = '#28a745';
            
            console.log('è¿ç»­PCMä¿å­˜å·²å¯åŠ¨');
        }
        
        function stopContinuousPcmSave() {
            if (!continuousPcmSave) return;
            
            continuousPcmSave = false;
            
            document.getElementById('continuousPcmButton').textContent = 'ğŸ”„ è¿ç»­ä¿å­˜';
            document.getElementById('continuousPcmButton').className = 'btn-primary';
            
            if (continuousPcmChunks.length > 0) {
                saveContinuousPcmFile();
            } else {
                document.getElementById('continuousPcmStatus').textContent = 'å·²å…³é—­';
                document.getElementById('continuousPcmStatus').style.color = '#666';
                alert('æ²¡æœ‰ä¿å­˜åˆ°éŸ³é¢‘æ•°æ®');
            }
            
            console.log('è¿ç»­PCMä¿å­˜å·²åœæ­¢');
        }
        
        function saveContinuousPcmFile() {
            try {
                if (continuousPcmChunks.length === 0) {
                    throw new Error('æ²¡æœ‰éŸ³é¢‘æ•°æ®');
                }
                
                console.log('å¼€å§‹ä¿å­˜è¿ç»­PCMæ–‡ä»¶...');
                console.log(`éŸ³é¢‘å—æ•°é‡: ${continuousPcmChunks.length}`);
                
                // è·å–ç¬¬ä¸€ä¸ªéŸ³é¢‘å—çš„å‚æ•°
                const firstChunk = continuousPcmChunks[0];
                const sampleRate = firstChunk.rate || 48000;
                const channels = firstChunk.channels || 2;
                const bytesPerSample = 2; // 16ä½
                
                // éªŒè¯æ‰€æœ‰éŸ³é¢‘å—çš„å‚æ•°ä¸€è‡´æ€§
                let totalBytes = 0;
                let isConsistent = true;
                
                continuousPcmChunks.forEach((chunk, index) => {
                    if (chunk.rate !== sampleRate || chunk.channels !== channels) {
                        console.warn(`éŸ³é¢‘å— ${index} å‚æ•°ä¸ä¸€è‡´: é‡‡æ ·ç‡ ${chunk.rate}Hz vs ${sampleRate}Hz, å£°é“æ•° ${chunk.channels} vs ${channels}`);
                        isConsistent = false;
                    }
                    totalBytes += chunk.size;
                });
                
                if (!isConsistent) {
                    console.warn('æ£€æµ‹åˆ°éŸ³é¢‘å‚æ•°ä¸ä¸€è‡´ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªéŸ³é¢‘å—çš„å‚æ•°');
                }
                
                console.log(`è¿ç»­PCMæ–‡ä»¶å‚æ•°: ${sampleRate}Hz, ${channels}å£°é“, ${totalBytes}å­—èŠ‚`);
                
                // åˆå¹¶æ‰€æœ‰éŸ³é¢‘æ•°æ®
                const pcmData = new Uint8Array(totalBytes);
                let dataOffset = 0;
                
                continuousPcmChunks.forEach(chunk => {
                    const chunkView = new Uint8Array(chunk.data);
                    pcmData.set(chunkView, dataOffset);
                    dataOffset += chunkView.byteLength;
                });
                
                // ä¸‹è½½PCMæ–‡ä»¶
                const blob = new Blob([pcmData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const duration = continuousPcmStartTime ? ((Date.now() - continuousPcmStartTime) / 1000).toFixed(1) : '0';
                const filename = `continuous_pcm_${sampleRate}Hz_${channels}ch_${duration}s_${timestamp}.pcm`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                
                // æ›´æ–°çŠ¶æ€
                document.getElementById('continuousPcmStatus').textContent = 'å·²ä¿å­˜';
                document.getElementById('continuousPcmStatus').style.color = '#28a745';
                
                console.log(`è¿ç»­PCMæ–‡ä»¶å·²ä¿å­˜: ${filename}`);
                alert(`è¿ç»­PCMæ–‡ä»¶å·²ä¿å­˜ä¸º: ${filename}\n\næ–‡ä»¶ä¿¡æ¯:\né‡‡æ ·ç‡: ${sampleRate}Hz\nå£°é“æ•°: ${channels}\néŸ³é¢‘å—æ•°: ${continuousPcmChunks.length}\næ€»æ—¶é•¿: ${duration}ç§’\næ•°æ®å¤§å°: ${(totalBytes / 1024 / 1024).toFixed(2)} MB`);
                
                // æ¸…ç†ç¼“å†²åŒº
                continuousPcmChunks = [];
                continuousPcmStartTime = null;
                
                // 3ç§’åé‡ç½®çŠ¶æ€
                setTimeout(() => {
                    document.getElementById('continuousPcmStatus').textContent = 'å·²å…³é—­';
                    document.getElementById('continuousPcmStatus').style.color = '#666';
                }, 3000);
                
            } catch (error) {
                console.error('ä¿å­˜è¿ç»­PCMæ–‡ä»¶å¤±è´¥:', error);
                alert('ä¿å­˜è¿ç»­PCMæ–‡ä»¶å¤±è´¥: ' + error.message);
                
                // æ›´æ–°çŠ¶æ€
                document.getElementById('continuousPcmStatus').textContent = 'ä¿å­˜å¤±è´¥';
                document.getElementById('continuousPcmStatus').style.color = '#dc3545';
                
                // 3ç§’åé‡ç½®çŠ¶æ€
                setTimeout(() => {
                    document.getElementById('continuousPcmStatus').textContent = 'å·²å…³é—­';
                    document.getElementById('continuousPcmStatus').style.color = '#666';
                }, 3000);
            }
        }
        
        // ==================== åº”ç”¨ç¨‹åºæ§åˆ¶åŠŸèƒ½ ====================
        
        // åº”ç”¨ç¨‹åºåˆ—è¡¨æ•°æ®
        let applicationsList = [];
        let filteredApplications = [];
        
        // å¤„ç†åº”ç”¨ç¨‹åºåˆ—è¡¨æ¶ˆæ¯
        function handleApplicationsList(message) {
            try {
                applicationsList = message.data || [];
                filteredApplications = [...applicationsList];
                
                updateApplicationsDisplay();
                updateLastUpdateTime(message.timestamp);
                
                console.log(`æ”¶åˆ°åº”ç”¨ç¨‹åºåˆ—è¡¨: ${applicationsList.length} ä¸ªåº”ç”¨ç¨‹åº`);
            } catch (error) {
                console.error('å¤„ç†åº”ç”¨ç¨‹åºåˆ—è¡¨å¤±è´¥:', error);
            }
        }
        
        // å¤„ç†å¯åŠ¨ç»“æœæ¶ˆæ¯
        function handleLaunchResult(message) {
            const launchStatus = document.getElementById('launchStatus');
            launchStatus.style.display = 'block';
            
            if (message.success) {
                launchStatus.style.background = '#d4edda';
                launchStatus.style.color = '#155724';
                launchStatus.style.border = '1px solid #c3e6cb';
                launchStatus.textContent = `âœ… ${message.message}`;
            } else {
                launchStatus.style.background = '#f8d7da';
                launchStatus.style.color = '#721c24';
                launchStatus.style.border = '1px solid #f5c6cb';
                launchStatus.textContent = `âŒ ${message.message}`;
            }
            
            // 3ç§’åéšè—çŠ¶æ€
            setTimeout(() => {
                launchStatus.style.display = 'none';
            }, 3000);
        }
        
        // æ›´æ–°åº”ç”¨ç¨‹åºæ˜¾ç¤º
        function updateApplicationsDisplay() {
            const container = document.getElementById('applicationsList');
            const countElement = document.getElementById('appCount');
            
            countElement.textContent = filteredApplications.length;
            
            if (filteredApplications.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #6c757d;">æ²¡æœ‰æ‰¾åˆ°åº”ç”¨ç¨‹åº</div>';
                return;
            }
            
            let html = '';
            filteredApplications.forEach((app, index) => {
                const appName = app.name || 'æœªçŸ¥åº”ç”¨ç¨‹åº';
                const exePath = app.exe_path || '';
                const fileName = app.filename || '';
                
                html += `
                    <div class="app-item" style="padding: 15px; border-bottom: 1px solid #f1f3f4; display: flex; justify-content: space-between; align-items: center;">
                        <div class="app-info" style="flex: 1;">
                            <div class="app-name" style="font-weight: bold; color: #495057; margin-bottom: 5px;">${appName}</div>
                            <div class="app-path" style="font-size: 0.85em; color: #6c757d; word-break: break-all;">${exePath}</div>
                            <div class="app-filename" style="font-size: 0.8em; color: #adb5bd;">${fileName}</div>
                        </div>
                        <div class="app-actions">
                            <button class="btn-success" data-exe-path="${exePath}" onclick="launchApplicationFromButton(this)" style="padding: 8px 15px; font-size: 0.9em;">
                                ğŸš€ å¯åŠ¨
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
        function updateLastUpdateTime(timestamp) {
            const timeElement = document.getElementById('lastUpdateTime');
            if (timestamp) {
                const date = new Date(timestamp * 1000);
                timeElement.textContent = `æœ€åæ›´æ–°: ${date.toLocaleString()}`;
            } else {
                timeElement.textContent = 'æœªæ›´æ–°';
            }
        }
        
        // ä»æŒ‰é’®è·å–è·¯å¾„å¹¶å¯åŠ¨åº”ç”¨ç¨‹åº
        function launchApplicationFromButton(button) {
            const exePath = button.getAttribute('data-exe-path');
            if (exePath) {
                launchApplication(exePath);
            } else {
                alert('æ— æ³•è·å–åº”ç”¨ç¨‹åºè·¯å¾„');
            }
        }
        
        // å¯åŠ¨åº”ç”¨ç¨‹åº
        function launchApplication(exePath) {
            if (!isConnected) {
                alert('è¯·å…ˆè¿æ¥åˆ°æœåŠ¡å™¨');
                return;
            }
            
            if (!exePath) {
                alert('åº”ç”¨ç¨‹åºè·¯å¾„æ— æ•ˆ');
                return;
            }
            
            // ç¡®ä¿è·¯å¾„ä¸­çš„åæ–œæ è¢«æ­£ç¡®å¤„ç†
            const normalizedPath = exePath.replace(/\\\\/g, '\\').replace(/\\/g, '\\');
            
            console.log('è¯·æ±‚å¯åŠ¨åº”ç”¨ç¨‹åº:', exePath);
            console.log('æ ‡å‡†åŒ–åçš„è·¯å¾„:', normalizedPath);
            
            websocket.send(JSON.stringify({
                type: 'launch_app',
                exe_path: normalizedPath
            }));
        }
        
        // åˆ·æ–°åº”ç”¨ç¨‹åºåˆ—è¡¨
        function refreshApplications() {
            if (!isConnected) {
                alert('è¯·å…ˆè¿æ¥åˆ°æœåŠ¡å™¨');
                return;
            }
            
            console.log('è¯·æ±‚åˆ·æ–°åº”ç”¨ç¨‹åºåˆ—è¡¨');
            // æœåŠ¡å™¨ä¼šæ¯5ç§’è‡ªåŠ¨å‘é€ä¸€æ¬¡ï¼Œè¿™é‡Œå¯ä»¥æ˜¾ç¤ºæç¤º
            document.getElementById('lastUpdateTime').textContent = 'æ­£åœ¨åˆ·æ–°...';
        }
        
        // æœç´¢åº”ç”¨ç¨‹åº
        function searchApplications() {
            const searchTerm = document.getElementById('appSearchInput').value.toLowerCase().trim();
            
            if (!searchTerm) {
                filteredApplications = [...applicationsList];
            } else {
                filteredApplications = applicationsList.filter(app => {
                    const name = (app.name || '').toLowerCase();
                    const filename = (app.filename || '').toLowerCase();
                    const path = (app.exe_path || '').toLowerCase();
                    
                    return name.includes(searchTerm) || 
                           filename.includes(searchTerm) || 
                           path.includes(searchTerm);
                });
            }
            
            updateApplicationsDisplay();
        }
        
        // ç›‘å¬æœç´¢è¾“å…¥æ¡†çš„å›è½¦é”®
        document.getElementById('appSearchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchApplications();
            }
        });
        
        // ==================== åº”ç”¨ç¨‹åºæ§åˆ¶åŠŸèƒ½ç»“æŸ ====================
        
        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', function() {
            if (websocket) {
                websocket.close();
            }
            if (audioContext) {
                audioContext.close();
            }
            // åœæ­¢æµ‹è¯•éŸ³é¢‘
            stopTestAudio();
            
            // åœæ­¢å½•åˆ¶
            if (isRecording) {
                stopRecording();
            }
            
            // åœæ­¢è¿ç»­PCMä¿å­˜
            if (continuousPcmSave) {
                stopContinuousPcmSave();
            }
        });
    </script>
</body>
</html>
